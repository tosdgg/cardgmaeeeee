<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Steampunk Tactical Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=Rye&display=swap" rel="stylesheet">
    <style>
        :root {
            --brass: #b5a642; --bronze: #cd7f32; --leather: #4a3c31;
            --parchment: #eaddcf; --dark-metal: #2c2c2c; --glow: #ffae00;
            --steam-blue: #00f3ff;
            --tier-1: #cd7f32; --tier-2: #c0c0c0; --tier-3: #ffd700;
        }

        body {
            margin: 0; padding: 0; background: #1a1510;
            color: var(--parchment); font-family: 'IM Fell English SC', serif;
            overflow: hidden; height: 100vh;
        }

        /* --- 頂部：多敵人動態生成 --- */
        #enemy-container {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px; justify-content: center; width: 95%;
        }

        .enemy-box {
            width: 260px; background: var(--dark-metal); border: 4px ridge var(--brass);
            padding: 12px; position: relative; transition: 0.3s;
        }

        /* 根據類型顯示邊框色 */
        .type-1 { border-color: var(--tier-1); }
        .type-2 { border-color: var(--tier-2); box-shadow: 0 0 10px var(--tier-2); }
        .type-3 { border-color: var(--tier-3); box-shadow: 0 0 20px var(--tier-3); }

        .row-id { font-size: 0.7rem; color: #888; font-family: monospace; }

        /* --- 側邊資訊 --- */
        #left-gauges {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 15px;
        }

        .gauge {
            width: 100px; background: var(--leather); border: 3px solid var(--bronze);
            border-radius: 12px; padding: 10px; text-align: center;
        }

        /* --- 按鈕：結束行動 --- */
        #end-action-btn {
            position: absolute; right: 30px; top: 50%; transform: translateY(-50%);
            width: 110px; height: 110px; border-radius: 50%;
            background: radial-gradient(circle, var(--bronze), var(--leather));
            border: 5px double var(--brass); color: white; cursor: pointer;
            font-family: 'Rye'; text-shadow: 1px 1px 2px #000;
        }

        /* --- 卡牌 --- */
        #hand-area {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; height: 280px; display: flex; justify-content: center;
            align-items: flex-end; pointer-events: none;
        }

        .card {
            width: 155px; height: 230px; background: var(--parchment); color: #221100;
            border: 4px solid var(--bronze); border-radius: 10px; margin: 0 -8px;
            pointer-events: auto; cursor: grab; position: relative;
        }
        
        .card-meta {
            position: absolute; top: -12px; left: -12px; text-align: center;
        }
        .card-cost {
            width: 38px; height: 38px; background: var(--dark-metal); color: var(--steam-blue);
            border: 2px solid var(--steam-blue); border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-family: 'Rye';
        }

        .hp-bar { width: 100%; height: 12px; background: #000; border-radius: 6px; overflow: hidden; margin: 8px 0; }
        .hp-fill { height: 100%; transition: 0.3s; background: #d93d3d; }

        .dragging { position: fixed !important; transform: scale(0.6) !important; pointer-events: none; z-index: 1000; }
    </style>
</head>
<body>

    <div id="enemy-container"></div>

    <div id="left-gauges">
        <div class="gauge">
            <div style="font-size:0.7rem">ROUND</div>
            <div id="round-val" style="font-family:'Rye'; font-size:1.8rem; color:var(--glow)">1</div>
        </div>
        <div class="gauge">
            <div style="font-size:0.7rem">ENERGY</div>
            <div id="energy-val" style="font-family:'Rye'; font-size:1.8rem; color:var(--steam-blue)">3/3</div>
        </div>
    </div>

    <div style="position:absolute; bottom:330px; left:50%; transform:translateX(-50%); width:400px; text-align:center;">
        <div style="display:flex; justify-content:space-between; font-size:0.8rem">
            <span>UNIT_PLAYER</span>
            <span id="player-hp-text">100 / 100</span>
        </div>
        <div class="hp-bar"><div id="player-hp-fill" class="hp-fill" style="background:#44ff44; width:100%"></div></div>
    </div>

    <button id="end-action-btn">END<br>ACTION</button>
    <div id="hand-area"></div>

    <script>
        let state = {
            playerHP: 100, playerMaxHP: 100,
            energy: 3, maxEnergy: 3,
            round: 1,
            enemiesOnField: [],
            allCards: [],
            allEnemyPool: []
        };

        // --- 載入邏輯 ---
        function loadGameData() {
            // 您原本的基礎 URL 請替換到這裡
            const baseUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRuNEG1oT6a0JsP4Zy8uqFSRDKaxEM8FJetpMWOZ0vR6yg4AGqGtMlLJ_0NSxIE_tqSnOsPd9aLWtg8/pub?output=csv"; 

            // 這裡用模擬數據演示格式
            const mockCards = `Name,Effect,Cost
精密狙擊,造成 [#dmg 40] 點傷害,2
緊急維修,自我修復 [#heal 20],1
超負荷指令,強制進入下一波 [#nextround 1],3`;
            
            const mockEnemies = `Name,HP,Type
發條蜘蛛,40,1
精英守衛,120,2
蒸汽神兵,400,3`;

            // 處理卡牌
            Papa.parse(mockCards, { header: true, complete: res => {
                state.allCards = res.data.map((r, i) => ({...r, row: i + 2}));
                drawCards(5);
            }});

            // 處理敵人
            Papa.parse(mockEnemies, { header: true, complete: res => {
                state.allEnemyPool = res.data.map((r, i) => ({...r, row: i + 2}));
                spawnWave();
            }});
        }

        function spawnWave() {
            state.enemiesOnField = [];
            // 每回合隨機抓 1-3 隻敵人
            const count = Math.floor(Math.random() * 3) + 1;
            for(let i=0; i<count; i++) {
                let data = state.allEnemyPool[Math.floor(Math.random()*state.allEnemyPool.length)];
                state.enemiesOnField.push({
                    ...data,
                    currentHP: parseInt(data.HP),
                    id: Date.now() + i
                });
            }
            renderEnemies();
        }

        function renderEnemies() {
            const container = document.getElementById('enemy-container');
            container.innerHTML = '';
            state.enemiesOnField.forEach(en => {
                const el = document.createElement('div');
                el.className = `enemy-box type-${en.Type}`;
                el.id = `en-${en.id}`;
                const hpPct = (en.currentHP / en.HP) * 100;
                el.innerHTML = `
                    <div style="font-family:'Rye'">${en.Name}</div>
                    <div class="row-id">From Row: ${en.row}</div>
                    <div class="hp-bar"><div class="hp-fill" style="width:${hpPct}%"></div></div>
                    <div style="font-size:0.7rem; text-align:right">${en.currentHP} / ${en.HP}</div>
                `;
                container.appendChild(el);
            });
        }

        function drawCards(num) {
            const hand = document.getElementById('hand-area');
            hand.innerHTML = '';
            for(let i=0; i<num; i++) {
                const data = state.allCards[Math.floor(Math.random()*state.allCards.length)];
                if(!data || !data.Name) continue;
                const cardEl = document.createElement('div');
                cardEl.className = 'card';
                cardEl.innerHTML = `
                    <div class="card-meta">
                        <div class="card-cost">${data.Cost}</div>
                        <div class="row-id">Row:${data.row}</div>
                    </div>
                    <div style="font-family:'Rye';padding:12px;text-align:center">${data.Name}</div>
                    <div style="padding:10px;font-size:0.8rem;text-align:center">${data.Effect}</div>
                `;
                bindDrag(cardEl, data);
                hand.appendChild(cardEl);
            }
        }

        function bindDrag(el, data) {
            el.onmousedown = (e) => {
                if(state.energy < data.Cost) return;
                const rect = el.getBoundingClientRect();
                el.classList.add('dragging');
                
                document.onmousemove = (ev) => {
                    el.style.left = ev.pageX - rect.width/2 + 'px';
                    el.style.top = ev.pageY - rect.height/2 - 50 + 'px';
                };

                document.onmouseup = (ev) => {
                    document.onmousemove = null;
                    const target = document.elementFromPoint(ev.clientX, ev.clientY);
                    const enemyEl = target?.closest('.enemy-box');

                    if(enemyEl) {
                        const enId = enemyEl.id.split('-')[1];
                        executeEffect(data.Effect, enId);
                        state.energy -= data.Cost;
                        el.remove();
                    } else {
                        el.classList.remove('dragging');
                        el.style.position = '';
                    }
                    updateUI();
                    document.onmouseup = null;
                };
            };
        }

        function executeEffect(effect, targetId) {
            const regex = /\[#(\w+)\s+(-?\d+)\]/g;
            let match;
            while ((match = regex.exec(effect)) !== null) {
                const tag = match[1];
                const val = parseInt(match[2]);

                if(tag === 'dmg') {
                    let en = state.enemiesOnField.find(e => e.id == targetId);
                    if(en) en.currentHP -= val;
                }
                if(tag === 'heal') {
                    state.playerHP = Math.min(state.playerMaxHP, state.playerHP + val);
                }
                if(tag === 'nextround') {
                    triggerNextRound();
                }
            }
            
            // 檢查敵人是否全滅
            state.enemiesOnField = state.enemiesOnField.filter(en => en.currentHP > 0);
            if(state.enemiesOnField.length === 0) triggerNextRound();
            else renderEnemies();
        }

        function triggerNextRound() {
            state.round++;
            state.energy = state.maxEnergy;
            spawnWave();
            drawCards(5);
            updateUI();
        }

        function endAction() {
            state.energy = state.maxEnergy;
            drawCards(5);
            updateUI();
        }

        function updateUI() {
            document.getElementById('energy-val').innerText = `${state.energy}/${state.maxEnergy}`;
            document.getElementById('round-val').innerText = state.round;
            document.getElementById('player-hp-fill').style.width = (state.playerHP/state.playerMaxHP)*100 + '%';
            document.getElementById('player-hp-text').innerText = `${state.playerHP} / ${state.playerMaxHP}`;
        }

        document.getElementById('end-action-btn').onclick = endAction;
        document.addEventListener('DOMContentLoaded', loadGameData);
    </script>
</body>
</html>
