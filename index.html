<!DOCTYPE html><html lang="zh-TW">
    <head>
    <meta charset="UTF-8">
    <title>Steampunk Duelist v6.0 - Fixed Logic</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=Rye&display=swap" rel="stylesheet">
    <style>
        :root {
            --brass: #b5a642; --bronze: #cd7f32; --gold: #ffd700;
            --leather: #4a3c31; --parchment: #eaddcf; --steam-blue: #00f3ff;
            --danger: #ff4444; --success: #44ff44;
        }

        body {
            margin: 0; padding: 0; background: #120f0d;
            color: var(--parchment); font-family: 'IM Fell English SC', serif;
            overflow: hidden; height: 100vh;
            background-image: radial-gradient(circle, #2a221b 0%, #120f0d 100%);
            transition: background 0.1s;
        }

        /* --- 戰鬥佈局 --- */
        #battle-stage {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 40px;
        }

        .round-gauge {
            width: 80px; height: 100px; background: var(--leather); border: 3px double var(--brass);
            border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        /* 敵人方塊與動態邊框 */
        .enemy-box {
            width: 420px; background: #222; border: 6px ridge var(--bronze);
            padding: 25px; border-radius: 5px; position: relative; cursor: pointer; transition: 0.3s;
        }
        
        /* 敵人類型 CSS */
        .tier-1 { border-color: #cd7f32 !important; animation: idle 2s infinite; }
        .tier-2 { border-color: #c0c0c0 !important; box-shadow: 0 0 20px rgba(192,192,192,0.3); animation: shake-mid 0.5s infinite; }
        .tier-3 { border-color: #ffd700 !important; box-shadow: 0 0 35px rgba(255,215,0,0.5); animation: shake-boss 0.15s infinite; }

        @keyframes idle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        @keyframes shake-mid { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } }
        @keyframes shake-boss { 0% { transform: translate(2px, 2px); } 50% { transform: translate(-2px, -2px); } }
        @keyframes damage-flash { 0% { background-color: rgba(255,0,0,0.3); } 100% { background-color: transparent; } }

        .target-active { outline: 3px solid var(--steam-blue); box-shadow: 0 0 30px var(--steam-blue); background: rgba(0,243,255,0.05); }

        /* --- 左側儀表板 --- */
        #side-panel { position: absolute; left: 30px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 20px; }
        .gauge-circle { width: 100px; height: 100px; border: 4px solid var(--brass); border-radius: 50%; background: radial-gradient(circle, var(--leather), #111); display: flex; flex-direction: column; align-items: center; justify-content: center; }

        /* --- 卡牌 --- */
        #hand-area { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 90%; height: 260px; display: flex; justify-content: center; align-items: flex-end; }
        .card { width: 160px; height: 230px; background: var(--parchment); color: #2a1a0a; border: 5px solid var(--bronze); border-radius: 12px; margin: 0 -5px; cursor: pointer; position: relative; transition: 0.2s; background-image: url('https://www.transparenttextures.com/patterns/pinstriped-suit.png'); }
        .card.selected { transform: translateY(-60px); border-color: var(--steam-blue); box-shadow: 0 10px 30px #000; }
        .card-cost { position: absolute; top: -15px; left: -15px; width: 40px; height: 40px; background: #222; color: var(--steam-blue); border: 2px solid var(--steam-blue); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-family: 'Rye'; font-size: 1.4rem; }
        .card-effect-num { margin-top: 40px; text-align: center; font-size: 1.8rem; font-family: 'Rye'; color: var(--bronze); }
        .card-row { position: absolute; bottom: 8px; right: 12px; font-size: 0.8rem; color: #842; }

        /* --- 血量條 --- */
        .hp-container { width: 100%; height: 22px; background: #000; border-radius: 11px; border: 2px solid var(--brass); overflow: hidden; margin: 10px 0; }
        .hp-fill { height: 100%; width: 100%; transition: 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28); }

        #player-hub { position: absolute; bottom: 320px; left: 50%; transform: translateX(-50%); width: 450px; cursor: pointer; padding: 10px; border-radius: 10px; }
        #player-action-log { position: absolute; top: -30px; left: 0; width: 100%; text-align: center; color: var(--danger); font-family: 'Rye'; text-shadow: 2px 2px 0 #000; opacity: 0; transition: 0.5s; }

        #end-btn { position: absolute; right: 40px; top: 50%; transform: translateY(-50%); width: 110px; height: 110px; border-radius: 50%; background: var(--bronze); border: 6px double var(--brass); color: #fff; font-family: 'Rye'; cursor: pointer; box-shadow: 0 5px 15px #000; }
        #end-btn:hover { background: #b87333; }
        #end-btn:active { transform: translateY(-50%) scale(0.95); }
    </style></head><body>

    <div id="battle-stage">
        <div class="round-gauge">
            <span style="font-size:0.7rem">ROUND</span>
            <span id="ui-round" style="font-family:'Rye'; font-size:2.2rem; color:var(--gold)">1</span>
        </div>
        <div class="enemy-box tier-1" id="enemy-target">
            <div id="ui-en-row" style="font-size:0.7rem; color: #888;">#--</div>
            <div id="ui-en-name" style="font-family:'Rye'; font-size:1.8rem;">LOADING SYSTEM...</div>
            <div class="hp-container"><div id="ui-en-hp-fill" class="hp-fill" style="background: var(--danger);"></div></div>
            <div id="ui-en-hp-text" style="text-align:right; font-weight:bold; font-size: 0.9rem;">-- / --</div>
            <div id="ui-en-intent" style="color:var(--steam-blue); font-size:0.8rem; margin-top:5px; height:1rem;"></div>
        </div>
    </div>

    <div id="side-panel">
        <div class="gauge-circle">
            <span style="font-size:0.7rem">ENERGY</span>
            <span id="ui-energy" style="font-family:'Rye'; font-size:2rem; color:var(--steam-blue)">3/3</span>
        </div>
        <div class="gauge-circle">
            <span style="font-size:0.7rem">WAVE LEFT</span>
            <span id="ui-wave-left" style="font-family:'Rye'; font-size:2rem">--</span>
        </div>
    </div>

    <div id="player-hub">
        <div id="player-action-log">TOOK 10 DAMAGE!</div>
        <div style="display:flex; justify-content:space-between; margin-bottom: 5px;">
            <span>PLAYER_SYSTEM_CORE</span>
            <span id="ui-pl-hp-text">100 / 100</span>
        </div>
        <div class="hp-container"><div id="ui-pl-hp-fill" class="hp-fill" style="background: var(--success);"></div></div>
    </div>

    <button id="end-btn">END<br>ACTION</button>
    <div id="hand-area"></div>

    <script>
        const BASE_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRuNEG1oT6a0JsP4Zy8uqFSRDKaxEM8FJetpMWOZ0vR6yg4AGqGtMlLJ_0NSxIE_tqSnOsPd9aLWtg8/pub?output=csv";
        const GID_CARD = "0";
        const GID_ENEMY = "322780304";
        const GID_CONFIG = "1319509950";

        let state = {
            playerHP: 100, energy: 3, round: 1,
            cardPool: [], enemyPool: [], waveConfig: [],
            currentWave: [], currentEnemy: null, enemyWaveIdx: 0,
            selectedCard: null
        };

        async function init() {
            // 策略：使用 header: false 來嚴格根據欄位索引 (Index) 讀取，避免標題錯誤
            
            // 1. 讀取卡片 (GID 0)
            Papa.parse(`${BASE_URL}&gid=${GID_CARD}`, { download: true, header: false, complete: (res) => {
                // 跳過第一列標題 (slice(1))
                state.cardPool = res.data.slice(1).filter(r => r[0]).map((r,i)=>({
                    name: r[0],         // A欄
                    effect: r[1],       // B欄
                    cost: parseInt(r[2])||0, // C欄
                    row: i+2
                }));
                draw(5);
            }});

            // 2. 讀取敵人 (GID 322780304)
            Papa.parse(`${BASE_URL}&gid=${GID_ENEMY}`, { download: true, header: false, complete: (res) => {
                state.enemyPool = res.data.slice(1).filter(r => r[0]).map((r,i)=>{
                    // A=0, B=1, C=2 (Type), D=3 (Skip), E~J=4~9 (Actions)
                    return { 
                        name: r[0], 
                        hp: parseInt(r[1])||10, 
                        type: parseInt(r[2])||1, 
                        actions: [r[4], r[5], r[6], r[7], r[8], r[9]].filter(a => a && a.trim() !== ""), 
                        row: i+2 
                    };
                });
                
                // 3. 讀取波次配置 (GID 1319509950)
                Papa.parse(`${BASE_URL}&gid=${GID_CONFIG}`, { download: true, header: false, complete: (res) => {
                    // A=Normal, B=Elite, C=Boss
                    state.waveConfig = res.data.slice(1).map(r => ({
                        n: parseInt(r[0])||0, 
                        e: parseInt(r[1])||0, 
                        b: parseInt(r[2])||0
                    }));
                    generateWave();
                }});
            }});
        }

        function generateWave() {
            const cfg = state.waveConfig[state.round - 1];
            if(!cfg) {
                alert("All Challenges Complete! You survived!");
                return;
            }
            
            let wave = [];
            // 嚴格比對 type (1, 2, 3)
            const add = (type, count) => {
                const p = state.enemyPool.filter(en => en.type === type);
                for(let i=0; i<count; i++) {
                    if(p.length) wave.push({...p[Math.floor(Math.random()*p.length)]});
                }
            };
            add(1, cfg.n); add(2, cfg.e); add(3, cfg.b);
            
            state.currentWave = wave;
            state.enemyWaveIdx = 0;
            spawnNext();
        }

        function spawnNext() {
            if(state.enemyWaveIdx < state.currentWave.length) {
                const raw = state.currentWave[state.enemyWaveIdx];
                state.currentEnemy = { ...raw, curHP: raw.hp, actionStep: 0 };
                state.enemyWaveIdx++;
                
                // 更新 UI 邊框與類別
                const box = document.getElementById('enemy-target');
                // 移除舊 class，保留基礎
                box.className = 'enemy-box';
                // 加入新 class
                box.classList.add(`tier-${state.currentEnemy.type}`);
                
                updateUI();
            } else {
                // 當前波次結束，進入下一 Round
                state.round++;
                generateWave();
            }
        }

        function draw(n) {
            const area = document.getElementById('hand-area');
            area.innerHTML = '';
            for(let i=0; i<n; i++){
                const d = state.cardPool[Math.floor(Math.random()*state.cardPool.length)];
                if(!d) continue;
                const el = document.createElement('div');
                el.className = 'card';
                // 視覺化：只顯示數字
                const showEff = d.effect.replace(/\[#\w+\s+(-?\d+)\]/g, '$1');
                el.innerHTML = `
                    <div class="card-cost">${d.cost}</div>
                    <div style="padding:10px;text-align:center;font-family:'Rye';font-size:1.1rem;border-bottom:1px solid #ccc">${d.name}</div>
                    <div class="card-effect-num">${showEff}</div>
                    <div class="card-row">Row:${d.row}</div>`;
                
                el.onclick = (e) => { 
                    e.stopPropagation(); 
                    if(state.energy >= d.cost) select(el, d); 
                };
                area.appendChild(el);
            }
        }

        function select(el, d) {
            if(state.selectedCard?.el === el) return cancel();
            cancel();
            state.selectedCard = {el, d};
            el.classList.add('selected');
            document.getElementById('enemy-target').classList.add('target-active');
            document.getElementById('player-hub').classList.add('target-active');
        }

        function cancel() {
            if(state.selectedCard) state.selectedCard.el.classList.remove('selected');
            state.selectedCard = null;
            document.querySelectorAll('.target-active').forEach(e => e.classList.remove('target-active'));
        }

        document.getElementById('enemy-target').onclick = () => { if(state.selectedCard) use("enemy"); };
        document.getElementById('player-hub').onclick = () => { if(state.selectedCard) use("player"); };

        function use(target) {
            const d = state.selectedCard.d;
            state.energy -= d.cost;
            
            // 解析效果
            const reg = /\[#(\w+)\s*(-?\d+)\]/g; // 允許空格彈性
            let m;
            while((m = reg.exec(d.effect)) !== null) {
                const tag = m[1], val = parseInt(m[2]);
                if(tag === 'dmg' && target === 'enemy') state.currentEnemy.curHP -= val;
                if(tag === 'heal') state.playerHP = Math.min(100, state.playerHP + val);
            }
            state.selectedCard.el.remove();
            cancel();
            
            if(state.currentEnemy.curHP <= 0) spawnNext();
            updateUI();
        }

        // --- 敵人反擊邏輯修復 ---
        function enemyCounter() {
            if(!state.currentEnemy || state.currentEnemy.curHP <= 0) return;
            const acts = state.currentEnemy.actions;
            if(!acts.length) return;
            
            const currentAct = acts[state.currentEnemy.actionStep % acts.length];
            
            // 解析動作 [#dmg 10]
            const reg = /\[#(\w+)\s*(-?\d+)\]/g; 
            let m;
            let tookDamage = 0;

            while((m = reg.exec(currentAct)) !== null) {
                const tag = m[1], val = parseInt(m[2]);
                if(tag === 'dmg') {
                    state.playerHP -= val;
                    tookDamage += val;
                }
            }

            // 傷害反饋視覺
            if(tookDamage > 0) {
                const log = document.getElementById('player-action-log');
                log.innerText = `TOOK ${tookDamage} DAMAGE!`;
                log.style.opacity = 1;
                document.body.style.animation = "damage-flash 0.3s";
                setTimeout(() => { 
                    log.style.opacity = 0; 
                    document.body.style.animation = "";
                }, 1000);
            }

            state.currentEnemy.actionStep++;
        }

        document.getElementById('end-btn').onclick = () => {
            enemyCounter(); // 先讓敵人攻擊
            state.energy = 3; // 重置能量
            draw(5); // 補牌
            updateUI();
        };

        function updateUI() {
            if(state.currentEnemy) {
                document.getElementById('ui-en-name').innerText = state.currentEnemy.name;
                document.getElementById('ui-en-row').innerText = `Sheet Row: ${state.currentEnemy.row}`;
                
                const enPct = (state.currentEnemy.curHP / state.currentEnemy.hp) * 100;
                document.getElementById('ui-en-hp-fill').style.width = Math.max(0, enPct) + '%';
                document.getElementById('ui-en-hp-text').innerText = `${state.currentEnemy.curHP} / ${state.currentEnemy.hp}`;

                // 顯示下一個動作預告 (Bonus UI)
                const acts = state.currentEnemy.actions;
                if(acts.length > 0) {
                    const nextAct = acts[state.currentEnemy.actionStep % acts.length];
                    document.getElementById('ui-en-intent').innerText = `INTENT: ${nextAct}`;
                }
            }

            document.getElementById('ui-round').innerText = state.round;
            document.getElementById('ui-energy').innerText = `${state.energy}/3`;
            document.getElementById('ui-wave-left').innerText = Math.max(0, state.currentWave.length - state.enemyWaveIdx);
            
            // 玩家血量
            document.getElementById('ui-pl-hp-text').innerText = `${state.playerHP} / 100`;
            document.getElementById('ui-pl-hp-fill').style.width = Math.max(0, state.playerHP) + '%';
            
            if(state.playerHP <= 0) {
                setTimeout(() => {
                    alert("SYSTEM FAILURE. Game Over.");
                    location.reload();
                }, 100);
            }
        }

        document.body.onclick = cancel;
        window.onload = init;
    </script>
    </body>
    </html>
